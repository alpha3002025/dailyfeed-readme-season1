> AI의 힘을 빌리지 않은 직접 작성한 글입니다.

<br/>

# 3. 서비스간 통신 시 인증 유효성 체크
서비스간 통신 시 에는 JWT 를 주고받으면서 인증된 사용자인지 검증합니다. 이때 서버 비공개키가 Refresh 된 경우, AccessToken 이 만료된 경우, RefreshToken 이 만료된 경우  이렇게 세 가지 경우의 인증 관련 시나리오가 존재합니다.

서버 비공개 키가 Refresh 된 경우
- `401 UnAuthorized, {X-Token-Refress-Needed: true}` 응답 헤더를 전파해서 클라이언트에서 POST /api/token/refresh 를 하도록 유도합니다.
- `POST /api/token/refresh` 를 수행하고 나면 새로운 AccessToken, RefreshToken 을 부여받게 됩니다.
- `POST /api/token/refresh` 는 frontend 에서 refreshToken 을 이용해서 요청하며, 서버에서도 refreshToken 을 읽어서 유효한지 검사합니다.
- Feign 관련 로직 내에 `401 UnAuthorized, {X-Token-Refress-Needed: true}`를 만났을 때에 대한 처리 로직이 있으며 `dailyfeed-feign` 모듈에 해당 기능들이 존재합니다.

AccessToken 이 만료되었을 경우
- `401 UnAuthorized, {X-Token-Refress-Needed: true}` 응답 헤더를 전파해서 클라이언트에서 POST /api/token/refresh 를 하도록 유도합니다.
- `POST /api/token/refresh` 를 수행하고 나면 새로운 AccessToken, RefreshToken 을 부여받게 됩니다.
- `POST /api/token/refresh` 는 frontend 에서 refreshToken 을 이용해서 요청하며, 서버에서도 refreshToken 을 읽어서 유효한지 검사합니다.
- Feign 관련 로직 내에 `401 UnAuthorized, {X-Token-Refress-Needed: true}`를 만났을 때에 대한 처리 로직이 있으며 `dailyfeed-feign` 모듈에 해당 기능들이 존재합니다.

RefreshToken 이 만료되었을 경우
- `401 UnAuthorized, {X-Relogin-Required: true}` 응답 헤더를 전파해서 login 을 새로 수행하도록 유도합니다.
- Feign 관련 로직 내에 `401 UnAuthorized, {X-Relogin-Required: true}`를 만났을 때에 대한 처리 로직이 있으며 `dailyfeed-feign` 모듈에 해당 기능들이 존재합니다.

<br/>



