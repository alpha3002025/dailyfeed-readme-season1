
`dailyfeed` 프로젝트에서는 Consumer Offset Commit 방식을 `At Least Once(최소 한번)`을 선택했습니다. 따라서 메시지가 중복되어 수신될 수 있는 가능성 역시 존재합니다. 중복되어 받은 메시지가 이미 받았던 메시지인지 체크하려면 메시지를 발급(publish) 할때 그 메시지의 고유 키를 생성해서 메시지 키로 전송하면, 해당 메시지가 중복 수신된 것인지 확인 가능합니다. `dailyfeed`프로젝트 에서는 `메시지 고유 키`를 발급하는 방식을 통해 메시지의 중복수신을 여부를 체크해 중복수신되지 않도록 했습니다.<br/>

나노세컨드 단위까지 고유한 키를 인식할 수 있도록 했으며, 이 보다 더 정밀한 고유키를 원한다면, `pod id` 등을  활용할수 있지만, 이번 프로젝트에서는 이 정도 레벨까지는 진행하지 않고, 나노세컨드 단위까지 고유한 키를 인식하고, 이미 발송된 메시지에 대해 같은 메시지가 생성될 경우(나노세컨드까지 일치하는 요청이 발생하면) `429 (TOO MANY REQUEST)` 응답을 하도록 보완했습니다.<br/>

만약 증권 거래 데이터 처리처럼 `트레이딩 봇` 이 나노세컨드 단위 이하까지로도 거래가 체결될수 있을지 등을 고려해야 하는 상황이라면, `pod id`와 함께 데이터 제공처의 `trasaction id` 를 활용해 고유키 인식을 해주면 됩니다.<br/>

비슷한 사례로 메신저 역시 비슷할 수 있는 상황이 발생할 수 있는데, 메시지의 경우 너무 잦은 요청은 Gateway 등을 통해 429 Response 를 하거나, 메시지 publisher 측에서도 나노세컨드 이하로의 정밀한 요청은 악의적인 요청으로 간주해 429 Response 등을 내려 보내서 다시 요청하도록 우회하는 것이 좋을 것이라고 생각합니다.(나 이거 왜 쓰고 있지?)<br/>
<br/>

# 메시지 키 형식
## `POST_CREATE`
글 작성시 생성되는 이벤트에 대한 메시지 키의 형식입니다.
- `member_activity:kafka_event:POST_CREATE###{postId}###{memberId}`
<br/>

# `POST_UPDATE`,`POST_DELETE`,`POST_READ`
글 수정/삭제/조회 시의 메시지 키의 형식입니다.
- `member_activity:kafka_event:{POST_UPDATE|POST_DELETE|POST_READ}###{postId}###{memberId}###{yyyy-MM-dd HH:mm:ss.SSSSSSSSS}`
<br/>

## `COMMENT_CREATE`
댓글/답글 작성시의 이벤트의 메시지 키의 형식입니다.
- `member_activity:kafka_event:COMMENT_CREATE###{postId}###{memberId}`
<br/>

## `COMMENT_UPDATE`,`COMMENT_DELETE`,`COMMENT_READ`
댓글/답글 수정/삭제/조회 시의 메시지 키의 형식입니다.
  - `member_activity:kafka_event:{COMMENT_UPDATE|COMMENT_DELETE|COMMENT_READ}###{commenttId}###{memberId}###{yyyy-MM-dd HH:mm:ss.SSSSSSSSS}`
<br/>
  
# `LIKE_POST`,` LIKE_POST_CANCEL`
글 좋아요,글 좋아요 취소 시의 메시지 키의 형식입니다.
  - `member_activity:kafka_event:{LIKE_POST|LIKE_POST_CANCEL}###{postId}###{memberId}`
<br/>
  
# `LIKE_COMMENT`, `LIKE_COMMENT_CANCEL`
댓글 좋아요,댓글 좋아요 취소 시의 메시지 키의 형식입니다.
  - `member_activity:kafka_event:{LIKE_COMMENT|LIKE_COMMENT_CANCEL}###{commentId}###{memberId}`

<br/>

# 메시지 키 체크 방식
![](./img/3-check-duplicated-message/how-to-check-duplicated.png)



